# Creating and Designing Databases



# An Example

We had a primary key constraint above, but there are other constraints.  The most important is foreign key, which links tables together.  But we can also enforce other constraints.

## Database Design

Let's work through an example of players and teams.  When we're designing our database, we want to avoid duplication as much as possible.

First Name  | Last Name  | Height  | Weight  | TeamName  | TeamCity  | StartingYear  | EndingYear 
:---|:---|---|---|:---|:---|---|---
LeBron | James | 81 | 249 | Cavaliers | Cleveland | 2003 | 2010
LeBron | James | 81 | 249 | Heat | Miami | 2010 | 2014
LeBron | James | 81 | 249 | Cavaliers | Cleveland | 2014 | 2018
LeBron | James | 81 | 249 | Lakers | Los Angeles | 2018 | 
Tim | Duncan | 82 | 256 | Spurs | San Antonio | 1997 | 2016
Chris | Paul | 72 | 175 | Hornets | New Orleans | 2005 | 2011
Chris | Paul | 72 | 175 | Clippers | Los Angeles | 2011 | 2017
Chris | Paul | 72 | 175 | Rockets | Houston | 2017 | 


What tables could we make to hold this data?

* player
* team
* player_team

Player:

id | first_name | last_name | height | weight
---|---|---|---|---
1 | LeBron | James | 81 | 249
2 | Tim | Duncan | 82 | 256 
3 | Chris | Paul | 72 | 175


Team:

id | name | city 
---|---|---
1 | Cavaliers | Cleveland
2 | Heat | Miami
3 | Spurs | San Antonio
4 | Hornets | New Orleans
5 | Clippers | Los Angeles
6 | Rockets | Houston
7 | Lakers | Los Angeles



Player-Team:

player_id | team_id | starting_year | ending_year
---|---|---|---
1 | 1 | 2003 | 2010
1 | 2 | 2010 | 2014
1 | 1 | 2014 | 2018
1 | 7 | 2018 | NULL
2 | 3 | 1997 | 2016
3 | 4 | 2005 | 2011
3 | 5 | 2011 | 2017
3 | 6 | 2017 | NULL


(We've simplified above to use the year and not the full date; we'd want a full date in reality because players can leave and rejoin a team during a season.)

## Table Creation

First, player table.  Start with the data types.

```sql
CREATE TABLE player ( 
	id INT,
	first_name TEXT, 
	last_name TEXT, 
	height SMALLINT, 
	weight SMALLINT
);
```

We're making the player id an imt type because we are assigning our own ids.  You could use a serial to automatically assign ID numbers.  That wouldn't prevent us from supplying our own ids, but doing so wiould potentially conflict with the autogenerated sequence ([more info](https://stackoverflow.com/questions/244243/how-to-reset-postgres-primary-key-sequence-when-it-falls-out-of-sync)).  Since we have to link players to teams later, we'll need to know what both the player ID and team ID are before we do the linking.  So we make this column just an int instead and assign IDs ourselves.  The downside of that is keeping track of what ids have already been used.

Add in constraints

```sql
CREATE TABLE player (
	id int PRIMARY KEY,
	first_name text NOT NULL,
	last_name text NOT NULL,
	height smallint CHECK (height > 0), 
	weight smallint
);
```

We use primary key like above, and also set the name columns to be not null.  We can also add in value constraints like ensuring that height is a positive number.

Moving on to the team table:

```sql
CREATE TABLE team (
	id smallint primary key, 
	name text not null,
	city text not null,
	unique (name, city)
);
```

For team, we added a constraint across two columns, saying that the combination of team name and city needs to be unique.

For player-team, start with types:

```sql
CREATE TABLE player_team ( 
	player_id int,
	team_id smallint, 
	start_year smallint, 
	end_year smallint
);
```

Add in constraints, a default value, and link ids to the other tables:

```sql
CREATE TABLE player_team (
	player_id int REFERENCES player(id),
	team_id smallint REFERENCES team(id), 
	start_year smallint NOT NULL, 
	end_year smallint DEFAULT NULL
);
```

The id columns, REFERENCES establishes a foreign key that constrains the values of `player_id` to be values that exist in the player table, id column.  For `team_id`, it has to take on values in the team table, id column.

An alternative format to specify the foreign keys is:

```sql
CREATE TABLE player_team (
	player_id int,
	team_id smallint, 
	start_year smallint not null, 
	end_year smallint default null,
	FOREIGN KEY (player_id) REFERENCES player(id),
	FOREIGN KEY (team_id) REFERENCES team(id)
);
```

We also set the start year to not be null, but for the end year, it defaults to null (this is the default, but we're being explicit).

Our player-team table is still missing a primary key.  We can't use player id and team id because players have left teams and later come back to them.  So we could use 3 columns: player id, team id, and start year (again, ignoring the possibility that a player leaves a team and rejoins in the same year):

```sql
CREATE TABLE player_team (
	player_id int references player(id),
	team_id smallint references team(id), 
	start_year smallint not null, 
	end_year smallint default null,
	PRIMARY KEY (player_id, team_id, start_year)
);
```

We could also just add an ID column to the table instead.  Having a primary key helps keep you from getting into a situation where you can't easily delete duplicate values from a table (or accidently introduce them in the first place).
